Index: defs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\r\n# from mpl_toolkits.mplot3d import Axes3Dimport\r\nfrom mpl_toolkits import mplot3d\r\nimport numpy as np\r\n\r\n\r\ndef geometry_cosine(r_hub, R, n):\r\n    r = np.linspace(0, np.pi, n + 1)\r\n    r = (1 - np.cos(r)) / 2\r\n    blen = R - r_hub\r\n    r = r_hub + blen * r\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef geometry_constant(r_hub, R, n):\r\n    r = np.linspace(r_hub, R, n + 1)\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef blade_geometry(radius):\r\n    # radial = [0, 0.3, .5, .8, 1]\r\n    # chorddist = [.05, .04, .03, .02, .015]\r\n    # twistdist = [-12, -8, -5, -4, 0.]\r\n    pitch = 2\r\n    chord = 3 * (1 - radius) + 1\r\n    twist = -14 * (1 - radius)\r\n    result = [chord, twist + pitch]\r\n    return result\r\n\r\n\r\ndef wake_system_generation(r_array, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio):\r\n    controlpoints = []\r\n    filaments = []\r\n    bound_filaments = []\r\n\r\n    Ur = U0 * (1 - a)  # axial velocity just after rotor\r\n    UD = U0 * (1 - 2 * a)  # axial velocity 'infinity' downwind of rotor\r\n\r\n    # U_wake = np.linspace(Ur, UD, nt)  # axial velocity at every discretised location in the wake\r\n    U_wake = Ur  # at least initially, as indicated by the tutorial\r\n\r\n    D = (r_array[-1] + 0.5 * dr[-1]) * 2  # rotor diameter\r\n    # z_wake = np.linspace(0, wakelength * D, nt)  # z(axial) coordinate of wake discretised points\r\n    # t_wake = np.zeros(nt)\r\n\r\n    n_rotations = (tip_speed_ratio * np.pi * wakelength) / (1 - a)\r\n    theta_array = np.arange(0, n_rotations * 2 * np.pi, np.pi / 10)\r\n\r\n    for blade_nr in range(number_of_blades):\r\n\r\n        angle_rotation = ((2 * np.pi) / number_of_blades) * blade_nr\r\n        print('rot=', angle_rotation)\r\n        cos_rotation = np.cos(angle_rotation)\r\n        sin_rotation = np.sin(angle_rotation)\r\n\r\n        # apply rotation to whole theta_array\r\n\r\n        for ri in range(len(r_array)-1):\r\n            geodef = blade_geometry(r_array[ri])  # chord, twist+pitch=phi\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            # define control points\r\n            temp1 = {\"coordinates\": [0, r_array[ri], 0],\r\n                     \"chord\": geodef[0],\r\n                     \"normal\": [np.cos(angle), 0, -1 * np.sin(angle)],\r\n                     \"tangential\": [-1 * np.sin(angle), 0, -1 * np.cos(angle)],\r\n                     \"blade\": blade_nr}\r\n\r\n            # rotate blade to position\r\n            temp1[\"coordinates\"] = [0,\r\n                                    temp1[\"coordinates\"][1] * cos_rotation - temp1[\"coordinates\"][2] * sin_rotation,\r\n                                    temp1[\"coordinates\"][1] * sin_rotation + temp1[\"coordinates\"][2] * cos_rotation]\r\n\r\n            temp1[\"normal\"] = [temp1[\"normal\"][0],\r\n                               temp1[\"normal\"][1] * cos_rotation - temp1[\"normal\"][2] * sin_rotation,\r\n                               temp1[\"normal\"][1] * sin_rotation + temp1[\"normal\"][2] * cos_rotation]\r\n\r\n            temp1[\"tangential\"] = [temp1[\"tangential\"][0],\r\n                                   temp1[\"tangential\"][1] * cos_rotation - temp1[\"tangential\"][2] * sin_rotation,\r\n                                   temp1[\"tangential\"][1] * sin_rotation + temp1[\"tangential\"][2] * cos_rotation]\r\n\r\n            controlpoints.append(temp1)\r\n\r\n            # define bound vortex filament & rotate filament to position\r\n            temp1 = {\"x1\": 0,\r\n                     \"y1\": r_array[ri] * cos_rotation,\r\n                     \"z1\": r_array[ri] * sin_rotation,\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri + 1] * cos_rotation,\r\n                     \"z2\": r_array[ri + 1] * sin_rotation,\r\n                     \"Gamma\": 0,\r\n                     \"blade\": blade_nr}\r\n\r\n            bound_filaments.append(temp1)\r\n\r\n            # create trailing filaments, at x1 (1st point) of bound filament\r\n            geodef = blade_geometry(r_array[ri] / R)\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            # temp1 = {\"x1\": geodef[0] * np.sin(-1 * angle),\r\n            #          \"y1\": r_array[ri],\r\n            #          \"z1\": 0,\r\n            #          \"x2\": 0,\r\n            #          \"y2\": r_array[ri],\r\n            #          \"z2\": 0,\r\n            #          \"Gamma\": 0,\r\n            #          \"blade\": blade_nr}\r\n\r\n            temp1 = {\"x1\": bound_filaments[\"blade\" == blade_nr][\"x1\"],\r\n                     \"y1\": bound_filaments[\"blade\" == blade_nr][\"y1\"],\r\n                     \"z1\": bound_filaments[\"blade\" == blade_nr][\"z1\"],\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri],\r\n                     \"z2\": 0,\r\n                     \"Gamma\": 0,\r\n                     \"blade\": blade_nr}\r\n\r\n            filaments.append(temp1)\r\n\r\n            for j in range(len(theta_array) - 1):\r\n                xt = filaments[len(filaments) - 1][\"x1\"]\r\n                yt = filaments[len(filaments) - 1][\"y1\"]\r\n                zt = filaments[len(filaments) - 1][\"z1\"]\r\n\r\n                dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n                dy = (np.cos(theta_array[j + 1]) - np.cos(theta_array[j])) * r_array[ri]\r\n                dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * r_array[ri]\r\n\r\n\r\n                temp1 = {\"x1\": xt + dx,\r\n                         \"y1\": yt + dy,\r\n                         \"z1\": zt + dz,\r\n                         \"x2\": xt,\r\n                         \"y2\": yt,\r\n                         \"z2\": zt,\r\n                         \"Gamma\": 0,\r\n                         \"blade\": blade_nr}\r\n\r\n                filaments.append(temp1)\r\n\r\n            # # create trailing filaments, at x2 (2nd point) of bound filament\r\n            # geodef = blade_geometry(r_array[ri + 1] / R)\r\n            # angle = geodef[1] * np.pi / 180\r\n            #\r\n            # # temp1 = {\"x1\": geodef[0] * np.sin(-1 * angle),\r\n            # #          \"y1\": r_array[ri + 1],\r\n            # #          \"z1\": -1 * geodef[0] * np.cos(angle),\r\n            # #          \"x2\": 0,\r\n            # #          \"y2\": r_array[ri + 1],\r\n            # #          \"z2\": 0,\r\n            # #          \"Gamma\": 0,\r\n            # #          \"blade\": blade_nr}\r\n            #\r\n            # temp1 = {\"x1\": bound_filaments[\"blade\" == blade_nr][\"x2\"],\r\n            #          \"y1\": bound_filaments[\"blade\" == blade_nr][\"y2\"],\r\n            #          \"z1\": bound_filaments[\"blade\" == blade_nr][\"z1\"],\r\n            #          \"x2\": 0,\r\n            #          \"y2\": r_array[ri + 1],\r\n            #          \"z2\": 0,\r\n            #          \"Gamma\": 0,\r\n            #          \"blade\": blade_nr}\r\n            #\r\n            # filaments.append(temp1)\r\n            # for j in range(len(theta_array) - 1):\r\n            #     xt = filaments[len(filaments) - 1][\"x2\"]\r\n            #     yt = filaments[len(filaments) - 1][\"y2\"]\r\n            #     zt = filaments[len(filaments) - 1][\"z2\"]\r\n            #\r\n            #     dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n            #     dy = (np.cos(theta_array[j + 1]) - np.cos(theta_array[j])) * r_array[ri + 1]\r\n            #     dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * r_array[ri + 1]\r\n            #\r\n            #\r\n            #     temp1 = {\"x1\": xt,\r\n            #              \"y1\": yt,\r\n            #              \"z1\": zt,\r\n            #              \"x2\": xt + dx,\r\n            #              \"y2\": yt + dy,\r\n            #              \"z2\": zt + dz,\r\n            #              \"Gamma\": 0,\r\n            #              \"blade\": blade_nr}\r\n            #\r\n            #     filaments.append(temp1)\r\n\r\n    return controlpoints, bound_filaments, filaments\r\n\r\n\r\nif __name__ == '__main__':\r\n    number_of_blades = 3\r\n    R = 50  # m\r\n    r_hub = 0.2 * R\r\n    U0 = 10\r\n    a = 0.25\r\n\r\n    # Constant or cosine element spacing on the blade\r\n    r, dr = geometry_constant(r_hub, R, 5)\r\n    # r,dr = geometry_cosine(r_hub,R,30)\r\n\r\n    wakelength = 0.05  # how many diameters long the wake shall be prescribed for\r\n    nt = 50\r\n    tip_speed_ratio = 8\r\n\r\n    cps, bound_filaments, fils = wake_system_generation(r, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio)\r\n\r\n    fig = plt.figure()\r\n    ax = plt.axes(projection=\"3d\")\r\n\r\n    for i in range(len(bound_filaments)):\r\n        x, y, z = [bound_filaments[i][\"x1\"], bound_filaments[i][\"x2\"]], \\\r\n                  [bound_filaments[i][\"y1\"], bound_filaments[i][\"y2\"]], \\\r\n                  [bound_filaments[i][\"z1\"], bound_filaments[i][\"z2\"]]\r\n        ax.plot(x, y, z, color='black')\r\n\r\n    for i in range(len(fils)):\r\n        x, y, z = [fils[i][\"x1\"], fils[i][\"x2\"]], [fils[i][\"y1\"], fils[i][\"y2\"]], [fils[i][\"z1\"], fils[i][\"z2\"]]\r\n        ax.plot(x, y, z, color='black')\r\n\r\n    for i in range(len(cps)):\r\n\r\n        x, y, z = cps[i][\"coordinates\"]\r\n        ax.scatter(x, y, z, c='red', s=100)\r\n\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/defs.py b/defs.py
--- a/defs.py	(revision b5175232da30095cb7271b4cfbff7805443cab6e)
+++ b/defs.py	(date 1652607114895)
@@ -50,8 +50,9 @@
     n_rotations = (tip_speed_ratio * np.pi * wakelength) / (1 - a)
     theta_array = np.arange(0, n_rotations * 2 * np.pi, np.pi / 10)
 
+
     for blade_nr in range(number_of_blades):
-
+        print(blade_nr)
         angle_rotation = ((2 * np.pi) / number_of_blades) * blade_nr
         print('rot=', angle_rotation)
         cos_rotation = np.cos(angle_rotation)
@@ -101,6 +102,10 @@
             geodef = blade_geometry(r_array[ri] / R)
             angle = geodef[1] * np.pi / 180
 
+
+
+
+
             # temp1 = {"x1": geodef[0] * np.sin(-1 * angle),
             #          "y1": r_array[ri],
             #          "z1": 0,
