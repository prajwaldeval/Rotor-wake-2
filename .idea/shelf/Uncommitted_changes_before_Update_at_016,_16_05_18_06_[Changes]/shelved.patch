Index: defs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\r\n# from mpl_toolkits.mplot3d import Axes3Dimport\r\nimport numpy as np\r\n\r\n\r\ndef geometry_cosine(r_hub, R, n):\r\n    r = np.linspace(0, np.pi, n + 1)\r\n    r = (1 - np.cos(r)) / 2\r\n    blen = R - r_hub\r\n    r = r_hub + blen * r\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef geometry_constant(r_hub, R, n):\r\n    r = np.linspace(r_hub, R, n + 1)\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef blade_geometry(radius):\r\n    # radial = [0, 0.3, .5, .8, 1]\r\n    # chorddist = [.05, .04, .03, .02, .015]\r\n    # twistdist = [-12, -8, -5, -4, 0.]\r\n    pitch = 2\r\n    chord = 3 * (1 - radius) + 1\r\n    twist = -14 * (1 - radius)\r\n    result = [chord, twist + pitch]\r\n    return result\r\n\r\n\r\ndef wake_system_generation(r_array, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio):\r\n    controlpoints = []\r\n    filaments = []\r\n\r\n    Ur = U0 * (1 - a)  # axial velocity just after rotor\r\n    UD = U0 * (1 - 2 * a)  # axial velocity 'infinity' downwind of rotor\r\n\r\n    # U_wake = np.linspace(Ur, UD, nt)  # axial velocity at every discretised location in the wake\r\n    U_wake = Ur  # at least initially, as indicated by the tutorial\r\n\r\n    D = (r_array[-1] + 0.5 * dr[-1]) * 2  # rotor diameter\r\n    # z_wake = np.linspace(0, wakelength * D, nt)  # z(axial) coordinate of wake discretised points\r\n    # t_wake = np.zeros(nt)\r\n\r\n    n_rotations = (tip_speed_ratio * np.pi * wakelength) / (1 - a)\r\n    theta_array = np.arange(0, n_rotations * 2 * np.pi, np.pi / 10)\r\n\r\n    angle_rotation_first_blade = 0\r\n    cos_rotation = np.cos(angle_rotation_first_blade)\r\n    sin_rotation = np.sin(angle_rotation_first_blade)\r\n\r\n    for ri in range(len(r_array) - 1):\r\n        geodef = blade_geometry(r_array[ri])  # chord, twist+pitch=phi\r\n        angle = geodef[1] * np.pi / 180\r\n\r\n        \"\"\"\" Defining Control Points \"\"\"\r\n        temp1 = {\"coordinates\": [0, r_array[ri], 0],\r\n                 \"chord\": geodef[0],\r\n                 \"normal\": [np.cos(angle), 0, -1 * np.sin(angle)],\r\n                 \"tangential\": [-1 * np.sin(angle), 0, -1 * np.cos(angle)]\r\n                 }\r\n\r\n        controlpoints.append(temp1)\r\n\r\n        \"\"\"\" Define Bound Vortex Filaments \"\"\"\r\n        temp1 = {\"x1\": 0,\r\n                 \"y1\": r_array[ri] - 0.5 * dr[ri],\r\n                 \"z1\": 0,\r\n                 \"x2\": 0,\r\n                 \"y2\": (r_array[ri + 1] - 0.5 * dr[ri + 1]),\r\n                 \"z2\": 0,\r\n                 \"Gamma\": 0}\r\n\r\n        filaments.append(temp1)\r\n\r\n        \"\"\"\" create trailing filaments, at x1 (1st point) of bound filament \"\"\"\r\n        geodef = blade_geometry(r_array[ri] / R)\r\n        angle = geodef[1] * np.pi / 180\r\n\r\n        # # my variant\r\n        # temp1 = {\"x1\": geodef[0] * np.sin(-angle),\r\n        #          \"y1\": (r_array[ri] - 0.5 * dr[ri]) * cos_rotation,\r\n        #          \"z1\": (r_array[ri] - 0.5 * dr[ri]) * sin_rotation,\r\n        #          \"x2\": 0,\r\n        #          \"y2\": (r_array[ri] - 0.5 * dr[ri]) * cos_rotation,\r\n        #          \"z2\": (r_array[ri] - 0.5 * dr[ri]) * sin_rotation,\r\n        #          \"Gamma\": 0}\r\n\r\n        # Ferreira's variant\r\n        temp1 = {\"x1\": geodef[0] * np.sin(-angle),\r\n                 \"y1\": (r_array[ri] - 0.5 * dr[ri]),\r\n                 \"z1\": -1 * geodef[0] * np.cos(angle),\r\n                 \"x2\": 0,\r\n                 \"y2\": (r_array[ri] - 0.5 * dr[ri]),\r\n                 \"z2\": 0,\r\n                 \"Gamma\": 0}\r\n\r\n        filaments.append(temp1)\r\n\r\n        for j in range(len(theta_array) - 1):\r\n            xt = filaments[len(filaments) - 1][\"x1\"]\r\n            yt = filaments[len(filaments) - 1][\"y1\"]\r\n            zt = filaments[len(filaments) - 1][\"z1\"]\r\n\r\n            dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n            dy = (np.cos(-theta_array[j + 1]) - np.cos(-theta_array[j])) * (r_array[ri] - 0.5 * dr[ri])\r\n            dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * (r_array[ri] - 0.5 * dr[ri])\r\n\r\n            temp1 = {\"x1\": xt + dx,\r\n                     \"y1\": yt + dy,\r\n                     \"z1\": zt + dz,\r\n                     \"x2\": xt,\r\n                     \"y2\": yt,\r\n                     \"z2\": zt,\r\n                     \"Gamma\": 0}\r\n\r\n            filaments.append(temp1)\r\n\r\n        \"\"\"\"\" create trailing filaments, at x2 (1st point) of bound filament \"\"\"\"\"\r\n        geodef = blade_geometry(r_array[ri] / R)\r\n        angle = geodef[1] * np.pi / 180\r\n\r\n        # # my variant\r\n        # temp2 = {\"x1\": geodef[0] * np.sin(angle),\r\n        #          \"y1\": (r_array[ri] + 0.5 * dr[ri]) * cos_rotation,\r\n        #          \"z1\": (r_array[ri] + 0.5 * dr[ri]) * sin_rotation,\r\n        #          \"x2\": 0,\r\n        #          \"y2\": (r_array[ri] + 0.5 * dr[ri]) * cos_rotation,\r\n        #          \"z2\": (r_array[ri] + 0.5 * dr[ri]) * sin_rotation,\r\n        #          \"Gamma\": 0}\r\n\r\n        # Ferreira's variant\r\n        temp2 = {\"x1\": 0,\r\n                 \"y1\": (r_array[ri + 1] - 0.5 * dr[ri + 1]),\r\n                 \"z1\": 0,\r\n                 \"x2\": geodef[0] * np.sin(-angle),\r\n                 \"y2\": (r_array[ri + 1] - 0.5 * dr[ri + 1]),\r\n                 \"z2\": -1 * geodef[0] * np.cos(angle),\r\n                 \"Gamma\": 0}\r\n\r\n        filaments.append(temp2)\r\n\r\n        for j in range(len(theta_array) - 1):\r\n            xt = filaments[len(filaments) - 1][\"x1\"]\r\n            yt = filaments[len(filaments) - 1][\"y1\"]\r\n            zt = filaments[len(filaments) - 1][\"z1\"]\r\n\r\n            dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n            dy = (np.cos(-theta_array[j + 1]) - np.cos(-theta_array[j])) * (r_array[ri + 1] - 0.5 * dr[ri + 1])\r\n            dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * (r_array[ri + 1] - 0.5 * dr[ri + 1])\r\n\r\n            temp1 = {\"x1\": xt + dx,\r\n                     \"y1\": yt + dy,\r\n                     \"z1\": zt + dz,\r\n                     \"x2\": xt,\r\n                     \"y2\": yt,\r\n                     \"z2\": zt,\r\n                     \"Gamma\": 0}\r\n\r\n            filaments.append(temp1)\r\n\r\n    return controlpoints, filaments\r\n\r\n\r\ndef biot_savart_function(fil_x1, fil_y1, fil_z1,\r\n                         fil_x2, fil_y2, fil_z2,\r\n                         cp_x, cp_y, cp_z,\r\n                         gamma):\r\n    R1 = np.sqrt((cp_x - fil_x1) ** 2 + (cp_y - fil_y1) ** 2 + (cp_z - fil_z1) ** 2)\r\n    R2 = np.sqrt((cp_x - fil_x2) ** 2 + (cp_y - fil_y2) ** 2 + (cp_z - fil_z2) ** 2)\r\n\r\n    R1_2X = (cp_y - fil_y1) * (cp_z - fil_z2) - (cp_z - fil_z1) * (cp_y - fil_y2)\r\n    R1_2Y = -(cp_x - fil_x1) * (cp_z - fil_z2) + (cp_z - fil_z1) * (cp_x - fil_x2)\r\n    R1_2Z = (cp_x - fil_x1) * (cp_y - fil_y2) - (cp_y - fil_y1) * (cp_x - fil_x2)\r\n\r\n    R12_sqr = R1_2X ** 2 + R1_2Y ** 2 + R1_2Z ** 2\r\n\r\n    R01 = (fil_x2 - fil_x1) * (cp_x - fil_x1) + (fil_y2 - fil_y1) * (cp_y - fil_y1) + (fil_z2 - fil_z1) * (\r\n            cp_z - fil_z1)\r\n    R02 = (fil_x2 - fil_x1) * (cp_x - fil_x2) + (fil_y2 - fil_y1) * (cp_y - fil_y2) + (fil_z2 - fil_z1) * (\r\n            cp_z - fil_z2)\r\n\r\n    K = gamma / (4 * np.pi * R12_sqr) * (R01 / R1 - R02 / R2)\r\n\r\n    u = K * R1_2X\r\n    v = K * R1_2Y\r\n    w = K * R1_2Z\r\n\r\n    return u, v, w\r\n\r\n\r\ndef unit_strength_induction_matrix():\r\n    \"\"\"\"\"\r\n     set up unit strength induction matrix\r\n     & initalize and calculate matrices for velocity induced by horseshoe vortex rings       \r\n    \"\"\"\"\"\r\n\r\n    # setting up unit induction matrix with the biot-savart function\r\n\r\n    unitU_ind = []\r\n    unitV_ind = []\r\n    unitW_ind = []\r\n\r\n    for ii in range(len(controlpoints)):\r\n        for nn in range(len(controlpoints)):\r\n            for jj = 1:2 * N_trail:\r\n                for nb in range(nr_of_blades)\r\n\r\n                    fil_x1 =\r\n                    fil_y1 =\r\n                    fil_z1 =\r\n                    fil_x2 =\r\n                    fil_y2 =\r\n                    fil_z2 =\r\n                    cp_x =\r\n                    cp_y =\r\n                    cp_z =\r\n                    gamma = 1\r\n                    uu, vv, ww = biot_savart_function(fil_x1, fil_y1, fil_z1,\r\n                                                        fil_x2, fil_y2, fil_z2,\r\n                                                        cp_x, cp_y, cp_z,\r\n                                                        gamma)\r\n\r\n    unitU_ind(ii, nn) = unitU_ind(ii, nn) + uu\r\n    unitV_ind(ii, nn) = unitV_ind(ii, nn) + vv\r\n    unitW_ind(ii, nn) = unitW_ind(ii, nn) + ww\r\n\r\n    return [unitU_ind, unitV_ind, unitW_ind]\r\n\r\nif __name__ == '__main__':\r\n    number_of_blades = 3\r\n    R = 50  # m\r\n    r_hub = 0.2 * R\r\n    U0 = 10\r\n    a = 0.25\r\n\r\n    # Constant or cosine element spacing on the blade\r\n    r, dr = geometry_constant(r_hub, R, 5)\r\n    # r,dr = geometry_cosine(r_hub,R,30)\r\n\r\n    wakelength = 0.1  # how many diameters long the wake shall be prescribed for\r\n    nt = 50\r\n    tip_speed_ratio = 8\r\n\r\n    cps, fils = wake_system_generation(r, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio)\r\n\r\n    fig = plt.figure()\r\n    ax = plt.axes(projection=\"3d\")\r\n\r\n    # for i in range(len(bound_fils_dict[\"x1\"])):\r\n    #     x, y, z = [bound_fils_dict[\"x1\"][i], bound_fils_dict[\"x2\"][i]], \\\r\n    #               [bound_fils_dict[\"y1\"][i], bound_fils_dict[\"y2\"][i]], \\\r\n    #               [bound_fils_dict[\"z1\"][i], bound_fils_dict[\"z2\"][i]]\r\n    #     ax.plot(x, y, z, color='black')\r\n\r\n    angle_rotation = ((2 * np.pi) / number_of_blades)\r\n\r\n    fils_new_blades = []\r\n    cps_new_blades = []\r\n\r\n    for blade_nr in range(number_of_blades):\r\n        theta = angle_rotation * blade_nr\r\n\r\n        for i in range(len(cps)):\r\n            # rotation around X-axis\r\n            temp1 = {\"coordinates\": [0,\r\n                                     cps[i][\"coordinates\"][1] * np.cos(theta) - cps[i][\"coordinates\"][2] * np.sin(\r\n                                         theta),\r\n                                     cps[i][\"coordinates\"][1] * np.sin(theta) + cps[i][\"coordinates\"][2] * np.cos(\r\n                                         theta)],\r\n\r\n                     \"chord\": 0,\r\n\r\n                     \"normal\": [cps[i][\"normal\"][0],\r\n                                cps[i][\"normal\"][1] * np.cos(theta) - cps[i][\"normal\"][2] * np.sin(theta),\r\n                                cps[i][\"normal\"][1] * np.sin(theta) + cps[i][\"normal\"][2] * np.cos(theta)],\r\n\r\n                     \"tangential\": [cps[i][\"tangential\"][0],\r\n                                    cps[i][\"tangential\"][1] * np.cos(theta) - cps[i][\"tangential\"][2] * np.sin(theta),\r\n                                    cps[i][\"tangential\"][1] * np.sin(theta) + cps[i][\"tangential\"][2] * np.cos(theta)]\r\n                     }\r\n\r\n            cps_new_blades.append(temp1)\r\n\r\n        for i in range(len(fils)):\r\n            temp_dict = {\"x1\": fils[i][\"x1\"],\r\n                         \"y1\": fils[i][\"y1\"] * np.cos(theta) - fils[i][\"z1\"] * np.sin(theta),\r\n                         \"z1\": fils[i][\"y1\"] * np.sin(theta) + fils[i][\"z1\"] * np.cos(theta),\r\n                         \"x2\": fils[i][\"x2\"],\r\n                         \"y2\": fils[i][\"y2\"] * np.cos(theta) - fils[i][\"z2\"] * np.sin(theta),\r\n                         \"z2\": fils[i][\"y2\"] * np.sin(theta) + fils[i][\"z2\"] * np.cos(theta),\r\n                         \"Gamma\": 0\r\n                         }\r\n\r\n            fils_new_blades.append(temp_dict)\r\n\r\n    for i in range(len(fils)):\r\n        x, y, z = [fils[i][\"x1\"], fils[i][\"x2\"]], [fils[i][\"y1\"], fils[i][\"y2\"]], [fils[i][\"z1\"], fils[i][\"z2\"]]\r\n        ax.plot(x, y, z, color='black')\r\n\r\n    for i in range(len(fils_new_blades)):\r\n        x, y, z = [fils_new_blades[i][\"x1\"], fils_new_blades[i][\"x2\"]], \\\r\n                  [fils_new_blades[i][\"y1\"], fils_new_blades[i][\"y2\"]], \\\r\n                  [fils_new_blades[i][\"z1\"], fils_new_blades[i][\"z2\"]]\r\n        ax.plot(x, y, z, color='black')\r\n\r\n    for i in range(len(cps)):\r\n        x, y, z = cps[i][\"coordinates\"]\r\n        ax.scatter(x, y, z, c='red', s=100)\r\n\r\n    for i in range(len(cps_new_blades)):\r\n        x, y, z = cps_new_blades[i][\"coordinates\"]\r\n        ax.scatter(x, y, z, c='red', s=100)\r\n\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/defs.py b/defs.py
--- a/defs.py	(revision 93ca1859a603356c6a6e89e9e9ed3a2b9897fe31)
+++ b/defs.py	(date 1652717178269)
@@ -200,7 +200,7 @@
 
     # setting up unit induction matrix with the biot-savart function
 
-    unitU_ind = []
+    unitU_ind = np.zeros((len(cps),number_of_blades*len()))
     unitV_ind = []
     unitW_ind = []
 
