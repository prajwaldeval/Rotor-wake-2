Index: defs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\r\n# from mpl_toolkits.mplot3d import Axes3Dimport\r\nfrom mpl_toolkits import mplot3d\r\nimport numpy as np\r\n\r\n\r\ndef geometry_cosine(r_hub, R, n):\r\n    r = np.linspace(0, np.pi, n + 1)\r\n    r = (1 - np.cos(r)) / 2\r\n    blen = R - r_hub\r\n    r = r_hub + blen * r\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef geometry_constant(r_hub, R, n):\r\n    r = np.linspace(r_hub, R, n + 1)\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef blade_geometry(radius):\r\n    # radial = [0, 0.3, .5, .8, 1]\r\n    # chorddist = [.05, .04, .03, .02, .015]\r\n    # twistdist = [-12, -8, -5, -4, 0.]\r\n    pitch = 2\r\n    chord = 3 * (1 - radius) + 1\r\n    twist = -14 * (1 - radius)\r\n    result = [chord, twist + pitch]\r\n    return result\r\n\r\n\r\ndef wake_system_generation(r_array, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio):\r\n    controlpoints = []\r\n    filaments = []\r\n\r\n    Ur = U0 * (1 - a)  # axial velocity just after rotor\r\n    UD = U0 * (1 - 2 * a)  # axial velocity 'infinity' downwind of rotor\r\n\r\n    # U_wake = np.linspace(Ur, UD, nt)  # axial velocity at every discretised location in the wake\r\n    U_wake = Ur  # at least initially, as indicated by the tutorial\r\n\r\n    D = (r_array[-1] + 0.5 * dr[-1]) * 2  # rotor diameter\r\n    # z_wake = np.linspace(0, wakelength * D, nt)  # z(axial) coordinate of wake discretised points\r\n    # t_wake = np.zeros(nt)\r\n\r\n    n_rotations = (tip_speed_ratio * np.pi * wakelength) / (1 - a)\r\n    theta_array = np.arange(0, n_rotations * 2 * np.pi, np.pi / 10)\r\n\r\n    for blade_nr in range(number_of_blades):\r\n\r\n        angle_rotation = (2 * np.pi) / ((blade_nr + 1) * number_of_blades)\r\n        cos_rotation = np.cos(angle_rotation)\r\n        sin_rotation = np.sin(angle_rotation)\r\n\r\n        for ri in range(len(r_array)-1):\r\n\r\n            geodef = blade_geometry(r_array[ri]/R)  # chord, twist+pitch=phi\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            # define control points\r\n            temp1 = {\"coordinates\": [0, ri, 0],\r\n                     \"chord\": geodef[0],\r\n                     \"normal\": [np.cos(angle), 0, -1 * np.sin(angle)],\r\n                     \"tangential\": [-1 * np.sin(angle), 0, -1 * np.cos(angle)]}\r\n\r\n            # rotate blade to position\r\n            temp1[\"coordinates\"] = [0, temp1[\"coordinates\"][1] * cos_rotation - temp1[\"coordinates\"][2] * sin_rotation,\r\n                                 temp1[\"coordinates\"][1] * sin_rotation + temp1[\"coordinates\"][2] * cos_rotation]\r\n\r\n            temp1[\"normal\"] = [temp1[\"normal\"][0], temp1[\"normal\"][1] * cos_rotation - temp1[\"normal\"][2] * sin_rotation,\r\n                            temp1[\"normal\"][1] * sin_rotation + temp1[\"normal\"][2] * cos_rotation]\r\n\r\n            temp1[\"tangential\"] = [temp1[\"tangential\"][0], temp1[\"tangential\"][1] * cos_rotation -\r\n                                temp1[\"tangential\"][2] * sin_rotation,\r\n                                temp1[\"tangential\"][1] * sin_rotation + temp1[\"tangential\"][2] * cos_rotation]\r\n\r\n            controlpoints.append(temp1)\r\n\r\n            # define bound vortex filament\r\n            temp1 = {\"x1\": 0,\r\n                     \"y1\": r_array[ri],\r\n                     \"z1\": 0,\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri + 1],\r\n                     \"z2\": 0,\r\n                     \"Gamma\": 0}\r\n\r\n            # rotate filament to position\r\n            filaments.append(temp1)\r\n\r\n            # create trailing filaments, at x1 (1st point) of bound filament\r\n            geodef = blade_geometry(r_array[ri] / R)\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            temp1 = {\"x1\": geodef[0] * np.sin(-1 * angle),\r\n                     \"y1\": r_array[ri],\r\n                     \"z1\": -1 * geodef[0] * np.cos(angle),\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri],\r\n                     \"z2\": 0,\r\n                     \"Gamma\": 0}\r\n\r\n            filaments.append(temp1)\r\n\r\n            for j in range(len(theta_array) - 1):\r\n                xt = filaments[len(filaments) - 1][\"x1\"]\r\n                yt = filaments[len(filaments) - 1][\"y1\"]\r\n                zt = filaments[len(filaments) - 1][\"z1\"]\r\n\r\n                dy = (np.cos(-theta_array[j + 1]) - np.cos(-theta_array[j])) * r_array[ri]\r\n                dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * r_array[ri]\r\n                dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n\r\n                temp1 = {\"x1\": xt + dx,\r\n                         \"y1\": yt + dy,\r\n                         \"z1\": zt + dz,\r\n                         \"x2\": xt,\r\n                         \"y2\": yt,\r\n                         \"z2\": zt,\r\n                         \"Gamma\": 0}\r\n\r\n                filaments.append(temp1)\r\n\r\n            # create trailing filaments, at x2 (2nd point) of bound filament\r\n            geodef = blade_geometry(r_array[ri + 1] / R)\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            temp1 = {\"x1\": geodef[0] * np.sin(-1 * angle),\r\n                     \"y1\": r_array[ri + 1],\r\n                     \"z1\": -1 * geodef[0] * np.cos(angle),\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri + 1],\r\n                     \"z2\": 0,\r\n                     \"Gamma\": 0}\r\n\r\n            filaments.append(temp1)\r\n            for j in range(len(theta_array) - 1):\r\n                xt = filaments[len(filaments) - 1][\"x2\"]\r\n                yt = filaments[len(filaments) - 1][\"y2\"]\r\n                zt = filaments[len(filaments) - 1][\"z2\"]\r\n\r\n                dy = (np.cos(-theta_array[j + 1]) - np.cos(-theta_array[j])) * r_array[ri + 1]\r\n                dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * r_array[ri + 1]\r\n                dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n\r\n                temp1 = {\"x1\": xt,\r\n                         \"y1\": yt,\r\n                         \"z1\": zt,\r\n                         \"x2\": xt + dx,\r\n                         \"y2\": yt + dy,\r\n                         \"z2\": zt + dz,\r\n                         \"Gamma\": 0}\r\n\r\n                filaments.append(temp1)\r\n\r\n            # define the trailing vortex filaments\r\n            # for j in range(1, nt):\r\n            #     t_wake[j] = t_wake[j - 1] + wakelength * D / U_wake[j] / nt\r\n\r\n            # n = len(r)  # number of horseshoe vortices per blade\r\n            # rw = np.zeros((nt, n))  # each row is one timestep, each column spanwise station\r\n            # thw = np.zeros((nt, n))\r\n            # print(rw)\r\n            # # for i in range(n):\r\n\r\n    return controlpoints, filaments\r\n\r\n\r\nif __name__ == '__main__':\r\n    number_of_blades = 2\r\n    R = 50  # m\r\n    r_hub = 0.2 * R\r\n    U0 = 10\r\n    a = 0.25\r\n\r\n    # Constant or cosine element spacing on the blade\r\n    r, dr = geometry_constant(r_hub, R, 20)\r\n    # r,dr = geometry_cosine(r_hub,R,30)\r\n\r\n    wakelength = 1  # how many dimaters long the wake shall be prescribed for\r\n    nt = 50\r\n    tip_speed_ratio = 8\r\n\r\n    cps, fils = wake_system_generation(r, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio)\r\n\r\n    fig = plt.figure()\r\n    ax = plt.axes(projection=\"3d\")\r\n\r\n    for i in range(len(fils)):\r\n\r\n        x, y, z = [fils[i][\"x1\"], fils[i][\"x2\"]], [fils[i][\"y1\"], fils[i][\"y2\"]], [fils[i][\"z1\"], fils[i][\"z2\"]]\r\n        # ax.scatter(x, y, z, c='red', s=100)\r\n        ax.plot(x, y, z, color='black')\r\n\r\n    plt.show()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/defs.py b/defs.py
--- a/defs.py	(revision 2b38535d9c1fb62668a4faadc093fee493f0c56d)
+++ b/defs.py	(date 1652536584871)
@@ -177,10 +177,10 @@
     a = 0.25
 
     # Constant or cosine element spacing on the blade
-    r, dr = geometry_constant(r_hub, R, 20)
+    r, dr = geometry_constant(r_hub, R, 5)
     # r,dr = geometry_cosine(r_hub,R,30)
 
-    wakelength = 1  # how many dimaters long the wake shall be prescribed for
+    wakelength = 0.2 # how many dimaters long the wake shall be prescribed for
     nt = 50
     tip_speed_ratio = 8
 
