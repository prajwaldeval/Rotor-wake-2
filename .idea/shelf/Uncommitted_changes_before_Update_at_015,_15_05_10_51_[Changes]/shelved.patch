Index: defs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\r\n# from mpl_toolkits.mplot3d import Axes3Dimport\r\nfrom mpl_toolkits import mplot3d\r\nimport numpy as np\r\n\r\n\r\ndef geometry_cosine(r_hub, R, n):\r\n    r = np.linspace(0, np.pi, n + 1)\r\n    r = (1 - np.cos(r)) / 2\r\n    blen = R - r_hub\r\n    r = r_hub + blen * r\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef geometry_constant(r_hub, R, n):\r\n    r = np.linspace(r_hub, R, n + 1)\r\n    dr = r[1:] - r[:-1]\r\n    r = (r[1:] + r[:-1]) / 2\r\n    return r, dr\r\n\r\n\r\ndef blade_geometry(radius):\r\n    # radial = [0, 0.3, .5, .8, 1]\r\n    # chorddist = [.05, .04, .03, .02, .015]\r\n    # twistdist = [-12, -8, -5, -4, 0.]\r\n    pitch = 2\r\n    chord = 3 * (1 - radius) + 1\r\n    twist = -14 * (1 - radius)\r\n    result = [chord, twist + pitch]\r\n    return result\r\n\r\n\r\ndef wake_system_generation(r_array, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio):\r\n    controlpoints = []\r\n    filaments = []\r\n\r\n    Ur = U0 * (1 - a)  # axial velocity just after rotor\r\n    UD = U0 * (1 - 2 * a)  # axial velocity 'infinity' downwind of rotor\r\n\r\n    # U_wake = np.linspace(Ur, UD, nt)  # axial velocity at every discretised location in the wake\r\n    U_wake = Ur  # at least initially, as indicated by the tutorial\r\n\r\n    D = (r_array[-1] + 0.5 * dr[-1]) * 2  # rotor diameter\r\n    # z_wake = np.linspace(0, wakelength * D, nt)  # z(axial) coordinate of wake discretised points\r\n    # t_wake = np.zeros(nt)\r\n\r\n    n_rotations = (tip_speed_ratio * np.pi * wakelength) / (1 - a)\r\n    theta_array = np.arange(0, n_rotations * 2 * np.pi, np.pi / 10)\r\n\r\n    for blade_nr in range(number_of_blades):\r\n\r\n        angle_rotation = ((2 * np.pi) / number_of_blades) * blade_nr\r\n        print('rot=', angle_rotation)\r\n        cos_rotation = np.cos(angle_rotation)\r\n        sin_rotation = np.sin(angle_rotation)\r\n\r\n        # apply rotation to whole theta_array\r\n        # theta_array = theta_array - angle_rotation\r\n\r\n        for ri in range(len(r_array)-1):\r\n            geodef = blade_geometry(r_array[ri])  # chord, twist+pitch=phi\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            # define control points\r\n            temp1 = {\"coordinates\": [0, r_array[ri], 0],\r\n                     \"chord\": geodef[0],\r\n                     \"normal\": [np.cos(angle), 0, -1 * np.sin(angle)],\r\n                     \"tangential\": [-1 * np.sin(angle), 0, -1 * np.cos(angle)],\r\n                     \"blade\": blade_nr}\r\n\r\n            # rotate blade to position\r\n            temp1[\"coordinates\"] = [0,\r\n                                    temp1[\"coordinates\"][1] * cos_rotation - temp1[\"coordinates\"][2] * sin_rotation,\r\n                                    temp1[\"coordinates\"][1] * sin_rotation + temp1[\"coordinates\"][2] * cos_rotation]\r\n\r\n            temp1[\"normal\"] = [temp1[\"normal\"][0],\r\n                               temp1[\"normal\"][1] * cos_rotation - temp1[\"normal\"][2] * sin_rotation,\r\n                               temp1[\"normal\"][1] * sin_rotation + temp1[\"normal\"][2] * cos_rotation]\r\n\r\n            temp1[\"tangential\"] = [temp1[\"tangential\"][0],\r\n                                   temp1[\"tangential\"][1] * cos_rotation - temp1[\"tangential\"][2] * sin_rotation,\r\n                                   temp1[\"tangential\"][1] * sin_rotation + temp1[\"tangential\"][2] * cos_rotation]\r\n\r\n            controlpoints.append(temp1)\r\n\r\n            # define bound vortex filament & rotate filament to position\r\n            temp1 = {\"x1\": 0,\r\n                     \"y1\": r_array[ri] * cos_rotation,\r\n                     \"z1\": r_array[ri] * sin_rotation,\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri + 1] * cos_rotation,\r\n                     \"z2\": r_array[ri + 1] * sin_rotation,\r\n                     \"Gamma\": 0,\r\n                     \"blade\": blade_nr}\r\n\r\n            filaments.append(temp1)\r\n\r\n            # create trailing filaments, at x1 (1st point) of bound filament\r\n            geodef = blade_geometry(r_array[ri] / R)\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            temp1 = {\"x1\": geodef[0] * np.sin(-1 * angle),\r\n                     \"y1\": r_array[ri],\r\n                     \"z1\": -1 * geodef[0] * np.cos(angle),\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri],\r\n                     \"z2\": 0,\r\n                     \"Gamma\": 0,\r\n                     \"blade\": blade_nr}\r\n\r\n            filaments.append(temp1)\r\n\r\n            for j in range(len(theta_array) - 1):\r\n                xt = filaments[len(filaments) - 1][\"x1\"]\r\n                yt = filaments[len(filaments) - 1][\"y1\"]\r\n                zt = filaments[len(filaments) - 1][\"z1\"]\r\n\r\n                dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n                dy = (np.cos(theta_array[j + 1]) - np.cos(theta_array[j])) * r_array[ri]\r\n                dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * r_array[ri]\r\n\r\n\r\n                temp1 = {\"x1\": xt + dx,\r\n                         \"y1\": yt + dy,\r\n                         \"z1\": zt + dz,\r\n                         \"x2\": xt,\r\n                         \"y2\": yt,\r\n                         \"z2\": zt,\r\n                         \"Gamma\": 0,\r\n                         \"blade\": blade_nr}\r\n\r\n                filaments.append(temp1)\r\n\r\n            # create trailing filaments, at x2 (2nd point) of bound filament\r\n            geodef = blade_geometry(r_array[ri + 1] / R)\r\n            angle = geodef[1] * np.pi / 180\r\n\r\n            temp1 = {\"x1\": geodef[0] * np.sin(-1 * angle),\r\n                     \"y1\": r_array[ri + 1],\r\n                     \"z1\": -1 * geodef[0] * np.cos(angle),\r\n                     \"x2\": 0,\r\n                     \"y2\": r_array[ri + 1],\r\n                     \"z2\": 0,\r\n                     \"Gamma\": 0,\r\n                     \"blade\": blade_nr}\r\n\r\n            filaments.append(temp1)\r\n            for j in range(len(theta_array) - 1):\r\n                xt = filaments[len(filaments) - 1][\"x2\"]\r\n                yt = filaments[len(filaments) - 1][\"y2\"]\r\n                zt = filaments[len(filaments) - 1][\"z2\"]\r\n\r\n                dx = (theta_array[j + 1] - theta_array[j]) / tip_speed_ratio * D / 2\r\n                dy = (np.cos(theta_array[j + 1]) - np.cos(theta_array[j])) * r_array[ri + 1]\r\n                dz = (np.sin(-theta_array[j + 1]) - np.sin(-theta_array[j])) * r_array[ri + 1]\r\n\r\n\r\n                temp1 = {\"x1\": xt,\r\n                         \"y1\": yt,\r\n                         \"z1\": zt,\r\n                         \"x2\": xt + dx,\r\n                         \"y2\": yt + dy,\r\n                         \"z2\": zt + dz,\r\n                         \"Gamma\": 0,\r\n                         \"blade\": blade_nr}\r\n\r\n                filaments.append(temp1)\r\n\r\n    return controlpoints, filaments\r\n\r\n\r\nif __name__ == '__main__':\r\n    number_of_blades = 3\r\n    R = 50  # m\r\n    r_hub = 0.2 * R\r\n    U0 = 10\r\n    a = 0.25\r\n\r\n    # Constant or cosine element spacing on the blade\r\n    r, dr = geometry_constant(r_hub, R, 20)\r\n    # r,dr = geometry_cosine(r_hub,R,30)\r\n\r\n    wakelength = 0.05  # how many diameters long the wake shall be prescribed for\r\n    nt = 50\r\n    tip_speed_ratio = 8\r\n\r\n    cps, fils = wake_system_generation(r, dr, U0, a, wakelength, number_of_blades, tip_speed_ratio)\r\n\r\n    fig = plt.figure()\r\n    ax = plt.axes(projection=\"3d\")\r\n\r\n    for i in range(len(fils)):\r\n        x, y, z = [fils[i][\"x1\"], fils[i][\"x2\"]], [fils[i][\"y1\"], fils[i][\"y2\"]], [fils[i][\"z1\"], fils[i][\"z2\"]]\r\n        ax.plot(x, y, z, color='black')\r\n\r\n    for i in range(len(cps)):\r\n\r\n        x, y, z = cps[i][\"coordinates\"]\r\n        ax.scatter(x, y, z, c='red', s=100)\r\n\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/defs.py b/defs.py
--- a/defs.py	(revision 53ef347eaeb80547c82d143a199783e0f9459f27)
+++ b/defs.py	(date 1652545919406)
@@ -50,7 +50,7 @@
     theta_array = np.arange(0, n_rotations * 2 * np.pi, np.pi / 10)
 
     for blade_nr in range(number_of_blades):
-
+        print(blade_nr)
         angle_rotation = ((2 * np.pi) / number_of_blades) * blade_nr
         print('rot=', angle_rotation)
         cos_rotation = np.cos(angle_rotation)
@@ -200,4 +200,4 @@
         x, y, z = cps[i]["coordinates"]
         ax.scatter(x, y, z, c='red', s=100)
 
-    plt.show()
+    # plt.show()
